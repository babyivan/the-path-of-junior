/*
 * Set/Multiset
 * ... ассоциативный массив в основе лежит бинарное дерево
 * !!! упорядоченная структура данных !!!
 * нельзя изменять существующие элементы (хак: можно найти и удалить нужный элемент и добавить новый).
 *
 * ---- Set ----
 * все значения - уникальные (дубляжей нет).
 *
 * ---- Multiset ----
 * позволяет добавить несколько одинаковых элементов.
 *
 * --- Операции ---
 * -> at()            - получить элемент по индексу (== arr[i]). Если выходим за границы - получаем exception.
 *                      работает медленнее чем [] поскольку проверяет выход за границу.
 * -> empty()         - проверка есть ли элементы в контейнере.
 * -> clear()         - очистить контейнер от всех элементов.
 * -> size()          - количество (размер) в контейнера.
 * -> find()          - поиск элемента в дереве. Если нашел - вернет итератор на элемент / если нет - вернет на end().
 *
 * --- Multiset Only
 * -> lower_bound()   - вернет итератор на первый повторяющийся элемент
 * -> upper_bound()   - вернет итератор на следующий элемент который будет после последнего повторяющего
 * -> equal_range()   - ???
 *
 * -------------------------------------------------------------------------------
 * -> insert()        - вставка элемента в лист по значению. Если успешно добавлено возращает iterator на элемент + true / false.
 * -> erase()         - удаление элемента из листа по занчению. Если элемента нет - ничего не происходит и метод возвращает 0
 *                      иначе возвращает 1.
 * ---
 * -> begin()         - возвращает итератор на первый элемент коллекции.
 * -> cbegin()        - возвращает const итератор на первый элемент коллекции.
 * -> rbegin()  C++11 - возвращает reverse итератор на первый элемент коллекции.
 * -> cregin()  C++11 - возвращает const reverse итератор на первый элемент коллекции.
 * ---
 * -> end()           - возвращает итератор на след. элемент который идет после последнего элемента в коллекции.
 * -> cend()    C++11 - возвращает const итератор на след. элемент который идет после последнего элемента в коллекции.
 * -> rend()          - возвращает reverse итератор на след. элемент который идет после последнего элемента в коллекции.
 * -> crend()   C++11 - возвращает const reverse итератор на след. элемент который идет после последнего элемента в коллекции.
 */

#include <iostream>
#include <set>

int main() {
  std::set<int> set = {10, -2, 5, 23, 86, 32};

  for (const auto &a : set) { std::cout << a << " "; }  // set = {-2, 5, 10, 23, 32, 86}
  std::cout << ((set.find(32) != set.end()) ? "item found" : "item not found") << std::endl;    // item found

////////////////////////

  std::multiset<int> mtset = {3, 32, 64, 4, 3, 100, 93};

  for (const auto &a : mtset) { std::cout << a << " "; }  // set = {3, 3, 4, 32, 64, 93, 100}

  mtset.lower_bound(3);  // set[0] - 3                               ^^
  mtset.upper_bound(3);  // set[2] - 4                                     ^^

  mtset.equal_range(3);  // ???


  return 0;
}
