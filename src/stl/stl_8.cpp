/*
 * Map/Multimap
 * ... ассоциативный массив в основе лежит бинарное дерево
 * !!! упорядоченная структура данных !!!
 * хранит pair (ключ/данные), построение дерева происходить по ключу
 * если тип данных - пользовательский - надо перегружать "==" в класе
 * [] - перегружен ([] - ключ), можно менять значение по ключу.
 *      Если такого клуча нет - вызов "map[KEY] = VAL" создаст новую пару и дабавит в коллекцию.
 *
 * ---- Map ----
 * все ключи - уникальны (дубляжей нет).
 *
 * ---- Multimap ----
 * позволяет добавить несколько одинаковых ключей.
 * [] - не перегружен.
 *
 * --- Операции ---
 * -> at()            - получить элемент по индексу (== arr[i]). Если выходим за границы - получаем exception.
 *                      работает медленнее чем [] поскольку проверяет выход за границу.
 * -> empty()         - проверка есть ли элементы в контейнере.
 * -> clear()         - очистить контейнер от всех элементов.
 * -> size()          - количество (размер) в контейнера.
 * -> find()          - поиск элемента в по ключу. Если нашел - вернет итератор на pair / если нет - вернет на end().
 * -------------------------------------------------------------------------------
 * -> insert()        - вставка пары в дерево.
 * -> emplace() C++11 - создает объект в момент выполения
 * -> erase()         - удаление элемента из листа по занчению. Если элемента нет - ничего не происходит и метод возвращает 0
 *                      иначе возвращает 1.
 * ---
 * -> begin()         - возвращает итератор на первый элемент коллекции.
 * -> cbegin()        - возвращает const итератор на первый элемент коллекции.
 * -> rbegin()  C++11 - возвращает reverse итератор на первый элемент коллекции.
 * -> cregin()  C++11 - возвращает const reverse итератор на первый элемент коллекции.
 * ---
 * -> end()           - возвращает итератор на след. элемент который идет после последнего элемента в коллекции.
 * -> cend()    C++11 - возвращает const итератор на след. элемент который идет после последнего элемента в коллекции.
 * -> rend()          - возвращает reverse итератор на след. элемент который идет после последнего элемента в коллекции.
 * -> crend()   C++11 - возвращает const reverse итератор на след. элемент который идет после последнего элемента в коллекции.
 */

#include <iostream>
#include <map>

int main() {
  std::map<int, std::string> map = {{10, "aaa"}, {-2, "bbb"}};

  map.insert(std::pair<int, std::string>(13, "ccc"));         // 3 способа добавления элемента
  map.insert(std::make_pair<int, std::string>(55, "ddd"));    // 3 способа добавления элемента
  map.emplace(61, "eee");                                      // 3 способа добавления элемента

  if (map.find(-2) != map.end()) {}       // Поиск элемента

  std::cout << map[-2] << std::endl;    // bbb

  map[7] = "fff";     // Если такого элемента нет в дереве - он добавиться
  //map.at(99);       // terminate called after throwing an instance of 'std::out_of_range'
  map.at(7) = "ggg";  // 7(fff) = 7(ggg)

  for (const auto &e : map) std::cout << "key: " << e.first << ", val: " << e.second << ". ";
  // key: -2, val: bbb. key: 7, val: ggg. key: 10, val: aaa. key: 13, val: ccc. key: 55, val: ddd. key: 61, val: eee.
  //
////////////////////////


  return 0;
}
