/*
 * lambda - функции
 * описание - "[]()->int {}" : "[]" - захват контекста, "()" - параметры, -">int" - тип возвращаемого значения "{}" - тело
 * можно передать параметром в функцию.
 * пространство внутри лямбды имеет свой контекст и не имеет по умолчанию доступа к внешнему контексту.
 * тип возвращаемого значение зависит от значения return.
 * mutable позволяет изменять захваченые по значению переменные но только в контексте лямбды.
 * можно захватить весь класс "[this](){}" - в лямбде будут доступны все методы и поля класса.
 *
 * --- [захват контекста] ---
 * int a = 5;
 * [&a]    - захват по ссылке
 * [a]     - захват по значению (можем только читать переменную)
 * [=]     - захват всех переменных в зоне видимости по значению
 * [&]     - захват всех переменных в зоне видимости по ссылке
 *
 * TODO: проработать нюансы
 * - Чем все-таки лямбды отличаются от анонимных функций
 * - Что лямбды являются синтаксическим сахаром для функторов
 * - Чем отличается захват контекста от передачи параметров, а именно, в какой момент происходит захват контекста
 * - Попробовать вернуть лямбду оператором return. Опасности, которые при этом возникают.﻿
 *
 */

#include <iostream>
#include <functional>

void do_work(const int &num, const std::function<int(int)> &f) {
  std::cout << f(num) << std::endl;
}

int main() {
  int num = 1;

  do_work(num, [](int a) {
    return a * 3;
  });                         // 3

  /////////////////////////////////

  int val_1 = 6;
  int val_2 = 8;

  auto f = [val_1, &val_2]() {
    //a1 = 2;   // error: assignment of read-only variable ‘val_1’
    val_2 = 45;
  };
  f();    // a1 = val_1, val_2 = 8
 /////////////////////////////////
 // mutable позволяет изменять захваченые по значению переменные но только в контексте лямбды
  auto f1 = [val_1, val_2]() mutable {
    val_1 = 53;     // val_1 = 53;
    val_2 = 645;    // val_2 = 645;
  };
  f1();     // val_1 = 6, val_2 = 45


  return 0;
}
